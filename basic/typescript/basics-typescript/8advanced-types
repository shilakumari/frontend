Module Introduction
Intersection Types
More on Type Guards
Discriminated Unions
Type Casting
Index Properties
Function Overloads
Optional Chaining
Nullish Coalescing
Useful Resources & Links

Intersection Types
type Admin = {
  name: string;
  privileges: string[];
};

type Employee = {
  name: string;
  startDate: Date;
};

// interface ElevatedEmployee extends Employee, Admin {}

type ElevatedEmployee = Admin & Employee;

const e1: ElevatedEmployee = {
  name: 'Max',
  privileges: ['create-server'],
  startDate: new Date()
};

type Combinable = string | number;
type Numeric = number | boolean;

type Universal = Combinable & Numeric;
let universal1:Universal=3;
console.log(typeof universal1);
//let universal2:Universal='ASD';//CTE,Type 'string' is not assignable to type 'number'


More on Type Guards
 	Type Guards using typeof
 		type Combinable = string | number;
		function add(a: Combinable, b: Combinable) {
			if (typeof a === 'string' || typeof b === 'string') {
			    return a.toString() + b.toString();
  			}
  			return a + b;
		}
		typeof works only for JavaScript predefined types but not for custom type like Employee
		
	Type Guards using 'in' keyword
		type UnknownEmployee = Employee | Admin;
		function printEmployeeInformation(emp: UnknownEmployee) {
  			console.log('Name: ' + emp.name);
  			if ('privileges' in emp) {
    			console.log('Privileges: ' + emp.privileges);
  			}
  			if ('startDate' in emp) {
    			console.log('Start Date: ' + emp.startDate);
  			}
		}
		printEmployeeInformation({ name: 'Manu', privileges: ['Shalu']});
		printEmployeeInformation({ name: 'Manu2', startDate: new Date() });
	
	Type Guards using instanceof keyword (It will not work with Interface)
		class Car {
  			drive() {
    			console.log('Driving...');
  			}
		}
		class Truck {
		  drive() {
    		console.log('Driving a truck...');
  		  }
		  loadCargo(amount: number) {
    		console.log('Loading cargo ...' + amount);
  		  }
		}
		type Vehicle = Car | Truck;
		const v1 = new Car();
		const v2 = new Truck();
		function useVehicle(vehicle: Vehicle) {
		  vehicle.drive();
		  if (vehicle instanceof Truck) {
    	 	vehicle.loadCargo(1000);
  		  }
	 	}
		useVehicle(v1);
		useVehicle(v2);

	What's a "Type Guard"?
		A code pattern where you check for a certain tpye before you try to do something with it at runtime.
		 With type guards you avoid runtime errors by checking types before you try to do something with the values.
	
	Which of the following type guards would ensure that you get NO runtime error?
		function size(input: string | number) {
  			if (typeof input === 'string') {
    			return input.length;
  			}
  			return input;
		}
	
Discriminated Unions
	It even with work interface.

	interface Bird {
  type: 'bird';
  flyingSpeed: number;
}

interface Horse {
  type: 'horse';
  runningSpeed: number;
}

type Animal = Bird | Horse;

function moveAnimal(animal: Animal) {
  let speed;
  switch (animal.type) {
    case 'bird':
      speed = animal.flyingSpeed;
      break;
    case 'horse':
      speed = animal.runningSpeed;
  }
  console.log('Moving at speed: ' + speed);
}

moveAnimal({type: 'bird', flyingSpeed: 10});
moveAnimal({type: 'horse', runningSpeed: 10});





Type Casting
	Using <>
		const userInputElement = <HTMLInputElement>document.getElementById('user-input')!;
	Using as
		const userInputElement2 = document.getElementById('user-input')! as HTMLInputElement;

	! ensure that expression before it will not yield a null value.
	
	const userInputElement3 = document.getElementById('user-input');
	userInputElement.value='Hi1';
	userInputElement2.value='Hi2';
	if (userInputElement3) {
	  (userInputElement3 as HTMLInputElement).value = 'Hi3 there!';
	}

	In which cases is type casting helpful?
		You want to inform TS that a certain value is of a specific type

Index Properties
	
interface ErrorContainer { // { email: 'Not a valid email', username: 'Must start with a character!' }
  [prop: string]: string;
}

const errorBag: ErrorContainer = {
  email: 'Not a valid email!',
  username: 'Must start with a capital character!'
};






Function Overloads
type Combinable = string | number;
function add(a: number, b: number): number;
function add(a: string, b: string): string;
function add(a: string, b: number): string;
function add(a: number, b: string): string;
function add(a: Combinable, b: Combinable) {
  if (typeof a === 'string' || typeof b === 'string') {
    return a.toString() + b.toString();
  }
  return a + b;
}

const result = add('Max', ' Schwarz');
result.split(' ');


Optional Chaining

const fetchedUserData = {
  id: 'u1',
  name: 'Max',
  job: { title: 'CEO', description: 'My own company' }
};

console.log(fetchedUserData?.job?.title);



Nullish Coalescing

const userInput = null;// null or undefined
const storedData1 = userInput || 'DEFAULT';
console.log(storedData1);//DEFAULT

const userInput2 = '';
const storedData2 = userInput2 || 'DEFAULT';
console.log(storedData2);//DEFAULT, we expected ''


const userInput3 = '';
const storedData3 = userInput3 ?? 'DEFAULT';
console.log(storedData3);// ''



Useful Resources & Links
More on Advanced Types: https://www.typescriptlang.org/docs/handbook/2/types-from-types.html
